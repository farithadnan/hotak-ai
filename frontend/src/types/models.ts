/**
 * TypeScript models that mirror the Python Pydantic models.
 * 
 * WHY WE NEED THIS:
 * - Type safety: Catch errors at compile-time instead of runtime
 * - Autocomplete: VS Code will suggest properties as you type
 * - Documentation: Interfaces serve as inline documentation
 * - Contract: Ensures frontend and backend agree on data structure
 */

// ==========================================
// TEMPLATE MODELS
// ==========================================

/**
 * Template Settings Interface
 * 
 * MIRRORS: app/models/template.py -> TemplateSettings
 * 
 * WHY: Each template can have custom AI behavior (model choice, temperature, etc.)
 * These settings control how the RAG system processes and responds to queries.
 * 
 * PROPERTIES EXPLAINED:
 * - model: Which OpenAI model to use (gpt-4o-mini, gpt-4o, etc.)
 * - temperature: Randomness (0 = deterministic, 1 = creative)
 * - chunk_size: How many characters per document chunk
 * - chunk_overlap: How much chunks overlap (prevents context loss)
 * - retrieval_k: How many relevant chunks to fetch from vector DB
 * - system_prompt: Custom instructions for the AI
 */
export interface TemplateSettings {
  model: string;
  temperature: number;
  chunk_size: number;
  chunk_overlap: number;
  retrieval_k: number;
  system_prompt: string;
}

/**
 * Template Create Interface
 * 
 * MIRRORS: app/models/template.py -> TemplateCreate
 * 
 * WHY: Used when CREATING a new template via POST /templates
 * Only includes fields the user provides (no id, timestamps, etc.)
 * 
 * OPTIONAL vs REQUIRED:
 * - name: REQUIRED (must provide)
 * - description: OPTIONAL (defaults to "")
 * - sources: OPTIONAL (defaults to empty array)
 * - settings: OPTIONAL (defaults to TemplateSettings defaults)
 */
export interface TemplateCreate {
  name: string;                        // Required
  description?: string;                // Optional (? means "might not exist")
  sources?: string[];                  // Optional array of URLs/paths
  settings?: TemplateSettings;         // Optional custom settings
}

/**
 * Template Interface (Full Model)
 * 
 * MIRRORS: app/models/template.py -> Template
 * 
 * WHY: Represents a COMPLETE template as stored in the database
 * Includes system-generated fields (id, created_at, updated_at)
 * 
 * WHEN USED:
 * - GET /templates -> returns array of Template[]
 * - GET /templates/{id} -> returns single Template
 * - POST /templates -> returns created Template
 * 
 * NOTE: All Python fields are required in TypeScript EXCEPT updated_at
 * which can be null if the template was never updated.
 */
export interface Template {
  id: string;                          // UUID generated by backend
  name: string;
  description: string;
  sources: string[];                   // Array of document URLs/paths
  settings: TemplateSettings;          // Nested object
  created_at: string;                  // ISO timestamp: "2026-02-05T10:30:00"
  updated_at: string | null;           // null if never updated
  source_count?: number;               // Optional: number of sources
}

/**
 * Template Update Interface
 * 
 * MIRRORS: app/models/template.py -> TemplateUpdate
 * 
 * WHY: Used for PARTIAL updates via PUT /templates/{id}
 * ALL fields are optional - only send what you want to change
 * 
 * EXAMPLE:
 * To only update the name:
 * { name: "New Name" }
 * 
 * PARTIAL TYPE EXPLAINED:
 * We could also use TypeScript's built-in Partial<Template>, but
 * explicit interface is clearer for learning.
 */
export interface TemplateUpdate {
  name?: string;
  description?: string;
  sources?: string[];
  settings?: TemplateSettings;
}

// ==========================================
// CHAT & MESSAGE MODELS (for future use)
// ==========================================

/**
 * Chat Session Interface
 * 
 * FUTURE USE: When we implement the chat feature
 * 
 * WHY: A chat is a conversation with attached templates
 * Users can have multiple chats, each with different knowledge bases
 * 
 * DESIGN DECISION:
 * - template_ids: Array because one chat can use multiple knowledge sources
 * - messages: Array of all conversation history
 */
export interface Chat {
  id: string;
  name: string;                        // e.g., "Python Help Session"
  template_ids: string[];              // Which templates this chat uses
  messages: Message[];                 // Conversation history
  created_at: string;
  updated_at: string | null;
}

/**
 * Message Interface
 * 
 * FUTURE USE: Individual messages in a chat
 * 
 * ROLE EXPLAINED:
 * - "user": Messages sent by the human
 * - "assistant": Responses from the AI
 * - "system": Internal instructions (usually hidden from UI)
 * 
 * SOURCES:
 * - Only present for assistant messages with RAG
 * - Shows which documents were cited
 */
export interface Message {
  id: string;
  chat_id: string;                     // Which chat this belongs to
  role: 'user' | 'assistant' | 'system';  // Limited to these 3 values
  content: string;                     // The actual message text
  sources?: string[];                  // URLs of cited sources (if RAG used)
  created_at: string;
}

/**
 * Message Create Interface
 * 
 * FUTURE USE: Sending a new message
 * 
 * WHY: User only provides content and role
 * Backend generates id, timestamp, and fetches sources via RAG
 */
export interface MessageCreate {
  role: 'user' | 'assistant';
  content: string;
}

// ==========================================
// API RESPONSE TYPES
// ==========================================

/**
 * Generic API Error Response
 * 
 * WHY: Standardized error handling
 * FastAPI returns errors in this format by default
 * 
 * USAGE:
 * try {
 *   const response = await fetch(...)
 *   if (!response.ok) {
 *     const error: ApiError = await response.json()
 *     console.error(error.detail)
 *   }
 * }
 */
export interface ApiError {
  detail: string;                      // Error message from backend
}

/**
 * Paginated Response (for future use)
 * 
 * WHY: When we have thousands of templates/chats
 * Instead of loading all at once, we can paginate
 * 
 * GENERIC TYPE <T>:
 * - PaginatedResponse<Template> for template lists
 * - PaginatedResponse<Chat> for chat lists
 */
export interface PaginatedResponse<T> {
  items: T[];                          // Array of actual data
  total: number;                       // Total count in database
  page: number;                        // Current page number
  page_size: number;                   // Items per page
  has_more: boolean;                   // Are there more pages?
}

// ==========================================
// TYPE GUARDS (Advanced TypeScript)
// ==========================================

/**
 * Type guard to check if something is a Template
 * 
 * WHY: Sometimes TypeScript can't infer types from API responses
 * This function does runtime checking
 * 
 * USAGE:
 * if (isTemplate(data)) {
 *   // TypeScript now knows 'data' is a Template
 *   console.log(data.name)
 * }
 */
export function isTemplate(obj: any): obj is Template {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.description === 'string' &&
    Array.isArray(obj.sources) &&
    typeof obj.settings === 'object' &&
    typeof obj.created_at === 'string'
  );
}

/**
 * Type guard for TemplateSettings
 */
export function isTemplateSettings(obj: any): obj is TemplateSettings {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof obj.model === 'string' &&
    typeof obj.temperature === 'number' &&
    typeof obj.chunk_size === 'number' &&
    typeof obj.chunk_overlap === 'number' &&
    typeof obj.retrieval_k === 'number' &&
    typeof obj.system_prompt === 'string'
  );
}

// ==========================================
// DEFAULT VALUES (Helper Constants)
// ==========================================

/**
 * Default template settings
 * 
 * WHY: Matches Python's Field defaults in TemplateSettings
 * Ensures consistency between frontend and backend
 * 
 * USAGE:
 * const newTemplate: TemplateCreate = {
 *   name: "My Template",
 *   settings: DEFAULT_TEMPLATE_SETTINGS  // Use defaults
 * }
 */
export const DEFAULT_TEMPLATE_SETTINGS: TemplateSettings = {
  model: "gpt-4o-mini",
  temperature: 0.2,
  chunk_size: 1000,
  chunk_overlap: 200,
  retrieval_k: 5,
  system_prompt: "You are a helpful AI assistant. Answer based on the provided context."
};

/**
 * Available model options
 * 
 * WHY: For dropdown menus in the UI
 * Users can select from these options when creating templates
 */
export const AVAILABLE_MODELS = [
  { value: "gpt-4o-mini", label: "GPT-4o Mini (Fast & Cheap)" },
  { value: "gpt-4o", label: "GPT-4o (Most Capable)" },
  { value: "gpt-4-turbo", label: "GPT-4 Turbo" },
  { value: "gpt-3.5-turbo", label: "GPT-3.5 Turbo (Cheapest)" }
] as const;
