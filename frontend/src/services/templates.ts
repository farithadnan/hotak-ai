import api, { getErrorMessage } from './api';
import type {
  Template,
  TemplateCreate,
  TemplateUpdate,
} from '../types/models';

/**
 * Create a new template
 * 
 * ENDPOINT: POST /templates
 * 
 * WHY THIS FUNCTION:
 * When user submits the template form, we need to:
 * 1. Send the data to backend
 * 2. Check for errors
 * 3. Return the created template with generated ID
 * 
 * FLOW:
 * User fills form → TemplateCreate object → POST /templates
 * Backend validates, generates ID, creates file
 * Returns full Template object with id + timestamps
 * 
 * PARAMETER EXPLANATION:
 * - data: TemplateCreate (from our models.ts)
 *   - name: string (required)
 *   - description?: string
 *   - sources?: string[]
 *   - settings?: TemplateSettings
 * 
 * RETURN TYPE: Promise<Template>
 * - Promise: We wait for the network request to complete
 * - Template: What we get back includes id, timestamps, etc.
 * 
 * ERROR HANDLING:
 * - If request fails, axios throws error
 * - We catch it, extract message, and re-throw
 * - Component catches this and shows error to user
 * 
 * TYPESCRIPT GENERICS EXPLAINED:
 * Promise<Template> = "This function will eventually give you a Template"
 */
export const createTemplate = async (data: TemplateCreate): Promise<Template> => {
  try {
    // POST /templates sends JSON body
    const response = await api.post<Template>('/templates', data);
    // response.data is the Template object returned by backend
    return response.data;
  } catch (error) {
    throw new Error(`Failed to create template: ${getErrorMessage(error as any)}`);
  }
};

/**
 * Get all templates
 * 
 * ENDPOINT: GET /templates
 * 
 * WHY:
 * Display list of all templates in the UI dropdown/table
 * This is the "list" operation in CRUD
 * 
 * RETURN TYPE: Promise<Template[]>
 * - The backend returns a plain list of templates
 * 
 * WHEN TO CALL:
 * - On app startup (load available templates)
 * - After creating/deleting template (refresh list)
 * - When user navigates to templates page
 */
export const getTemplates = async (): Promise<Template[]> => {
  try {
    const response = await api.get<Template[]>('/templates');
    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch templates: ${getErrorMessage(error as any)}`);
  }
};

/**
 * Get single template by ID
 * 
 * ENDPOINT: GET /templates/{id}
 * 
 * WHY:
 * Load full details of a specific template for editing
 * 
 * PARAMETER:
 * - id: string (UUID generated by backend)
 *   Example: "d32039af-ca18-486d-9cd6-488ffa34ef84"
 * 
 * USAGE:
 * const template = await getTemplate(selectedId);
 * populateFormWithValues(template); // Prefill edit form
 * 
 * ERROR HANDLING:
 * If template not found, backend returns 404
 * Error handler extracts the detail message
 */
export const getTemplate = async (id: string): Promise<Template> => {
  try {
    const response = await api.get<Template>(`/templates/${id}`);
    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch template: ${getErrorMessage(error as any)}`);
  }
};

/**
 * Update an existing template
 * 
 * ENDPOINT: PUT /templates/{id}
 * 
 * WHY:
 * User edited some template settings, we need to save changes
 * This is the "update" operation in CRUD
 * 
 * PARAMETERS:
 * - id: string (which template to update)
 * - data: TemplateUpdate (what to change)
 *   Note: ALL fields in TemplateUpdate are optional (?)
 *   So user can update just the name, leaving others unchanged
 * 
 * EXAMPLE:
 * // Only updating the name
 * await updateTemplate(templateId, { name: "New Name" })
 * 
 * // Updating multiple fields
 * await updateTemplate(templateId, {
 *   name: "New Name",
 *   description: "Better description",
 *   settings: { temperature: 0.5 }
 * })
 * 
 * RETURN:
 * Full updated Template object (in case something changed on backend)
 */
export const updateTemplate = async (
  id: string,
  data: TemplateUpdate
): Promise<Template> => {
  try {
    const response = await api.put<Template>(`/templates/${id}`, data);
    return response.data;
  } catch (error) {
    throw new Error(`Failed to update template: ${getErrorMessage(error as any)}`);
  }
};

/**
 * Delete a template
 * 
 * ENDPOINT: DELETE /templates/{id}
 * 
 * WHY:
 * User wants to remove a template (and all associated data)
 * This is the "delete" operation in CRUD
 * 
 * PARAMETER:
 * - id: string (which template to delete)
 * 
 * RETURN TYPE: Promise<void>
 * - void = we don't expect any data back
 * - Backend just returns 200 OK if successful
 * 
 * USAGE:
 * await deleteTemplate(templateId);
 * // Then refresh template list
 * const templates = await getTemplates();
 * 
 * WARNING:
 * This is destructive (can't be undone)
 * UI should ask for confirmation before calling this
 */
export const deleteTemplate = async (id: string): Promise<void> => {
  try {
    await api.delete(`/templates/${id}`);
    // If we got here, delete was successful
  } catch (error) {
    throw new Error(`Failed to delete template: ${getErrorMessage(error as any)}`);
  }
};
